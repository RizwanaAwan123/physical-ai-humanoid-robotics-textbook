---
id: chapter3-sections-3-2-forward-kinematics
title: "Forward Kinematics: Position and Orientation of End-Effectors"
---

## 3.2 Forward Kinematics: Position and Orientation of End-Effectors

Forward kinematics is the process of calculating the position and orientation of a robot's end-effector (e.g., a hand, foot, or tool) in a fixed coordinate system, given the joint angles (or positions) of all its links. This is a fundamental problem in robotics, as it allows us to understand where the robot's operational parts are in space based on its internal configuration.

### Denavit-Hartenberg (D-H) Parameters

The Denavit-Hartenberg (D-H) convention is a systematic approach to assigning coordinate frames to each link of a robot and deriving the transformation matrices between them. For a serial link manipulator, each joint is associated with four D-H parameters: $a$, $\alpha$, $d$, and $\theta$.

*   $a$: link length (distance between $Z_{i-1}$ and $Z_i$ measured along $X_i$)
*   $\alpha$: link twist (angle between $Z_{i-1}$ and $Z_i$ measured about $X_i$)
*   $d$: link offset (distance between $X_{i-1}$ and $X_i$ measured along $Z_{i-1}$)
*   $\theta$: joint angle (angle between $X_{i-1}$ and $X_i$ measured about $Z_{i-1}$)

The transformation matrix from frame $i-1$ to frame $i$ is $A_i$:

```latex
A_i = \begin{pmatrix}
    \cos\thet-i & -\sin\thet-i\cos\alph-i & \sin\thet-i\sin\alph-i & -i\cos\thet-i \\
    \sin\thet-i & \cos\thet-i\cos\alph-i & -\cos\thet-i\sin\alph-i & -i\sin\thet-i \\
    0 & \sin\alph-i & \cos\alph-i & d_i \\
    0 & 0 & 0 & 1
\end{pmatrix}
```

The overall transformation from the base frame (0) to the end-effector frame ($N$) is the product of these individual link transformations:

```latex
T_0^N = A_1 A_2 \cdots A_N
```

### Example: 2R Planar Arm Forward Kinematics in Python

Consider a simple 2-revolute (2R) planar manipulator. Here, we calculate the end-effector position given two joint angles.

```python
import numpy as np

def forward_kinematics_2r_planar(l1, l2, theta1_deg, theta2_deg):
    theta1_rad = np.deg2rad(theta1_deg)
    theta2_rad = np.deg2rad(theta2_deg)

    x = l1 * np.cos(theta1_rad) + l2 * np.cos(theta1_rad + theta2_rad)
    y = l1 * np.sin(theta1_rad) + l2 * np.sin(theta1_rad + theta2_rad)

    return np.array([x, y])

# Link lengths
l1 = 1.0 # meter
l2 = 0.8 # meter

# Joint angles
theta1 = 30 # degrees
theta2 = 60 # degrees

end_effector_pos = forward_kinematics_2r_planar(l1, l2, theta1, theta2)
print(f"End-effector position for (theta1={theta1} deg, theta2={theta2} deg): {end_effector_pos}")

# Example with ROS (conceptual, as full ROS environment is complex for snippet)
# In a ROS environment, you would publish joint states and use TF (Transform Library)
# to get the end-effector pose. For example:
# rosrun tf tf_echo /base_link /end_effector_link
```

### ASCII Diagram: 2R Planar Manipulator

```
  Y ^
    |
  L1|
    O---- (Joint 1)
   / \  theta1
  /   \ L2
 (Base)  O---- (End-Effector)
        / theta2
       /
      -----> X
```

### Multiple Choice Question

Which convention is commonly used for systematically assigning coordinate frames to robot links in forward kinematics?

a) Euler angles

b) Quaternions

c) Denavit-Hartenberg parameters

d) Roll-Pitch-Yaw angles

**Answer:** c)

### Short Question

Explain the difference between a `revolute` joint and a `prismatic` joint in the context of D-H parameters. How would their D-H parameters differ?

### Assignment

Derive the forward kinematics equations for a 3R planar manipulator (three revolute joints in a plane) with link lengths $l_1, l_2, l_3$ and joint angles $\theta_1, \theta_2, \theta_3$. Implement this in Python and calculate the end-effector position for given link lengths and joint angles. Assume all links are in the XY-plane and rotate about the Z-axis.
