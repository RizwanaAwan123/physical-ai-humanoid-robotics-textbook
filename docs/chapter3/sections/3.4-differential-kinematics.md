---
id: chapter3-sections-3-4-differential-kinematics
title: "Differential Kinematics: Velocities and Jacobians"
---

## 3.4 Differential Kinematics: Velocities and Jacobians

Differential kinematics deals with the relationship between joint velocities and end-effector velocities. It is crucial for real-time robot control, trajectory generation, and understanding how small changes in joint angles affect the end-effector's motion. The central tool in differential kinematics is the Jacobian matrix.

### The Jacobian Matrix

The Jacobian matrix $J$ relates the joint velocity vector $\dot{\mathbf{q}}$ to the end-effector velocity (linear and angular) vector $\dot{\mathbf{x}}$:

```latex
\dot{\mathbf{x}} = J(\mathbf{q}) \dot{\mathbf{q}}
```

Where:
*   $\dot{\mathbf{x}} = \begin{pmatrix} \mathbf{v} \\ \boldsymbol{\omega} \end{pmatrix}$ is the $6 \times 1$ end-effector twist vector (linear velocity $\mathbf{v}$ and angular velocity $\boldsymbol{\omega}$).
*   $\dot{\mathbf{q}}$ is the $N \times 1$ joint velocity vector for an $N$-degree-of-freedom robot.
*   $J$ is a $6 \times N$ matrix whose elements are functions of the current joint configuration $\mathbf{q}$.

The Jacobian can be partitioned into a linear velocity part ($J_v$) and an angular velocity part ($J_{\omega}$).

```latex
J = \begin{pmatrix} J_v \\ J_{\omega} \end{pmatrix}
```

### Singularities

Robot singularities are configurations where the Jacobian matrix loses rank, meaning the robot loses one or more degrees of freedom for its end-effector. At these points, the robot cannot move its end-effector in certain directions, even if its joints are actuated. This is analogous to a human arm fully extended, where the wrist might not be able to move sideways.

### Example: Jacobian for a 2R Planar Arm in Python

For a 2R planar arm, the end-effector position $(x, y)$ is:

```latex
x = l_1 \cos(\theta_1) + l_2 \cos(\theta_1 + \theta_2)
y = l_1 \sin(\theta_1) + l_2 \sin(\theta_1 + \theta_2)
```

The Jacobian matrix is derived by taking partial derivatives with respect to each joint angle:

```latex
J = \begin{pmatrix}
    \frac{\partial x}{\partial \theta_1} & \frac{\partial x}{\partial \theta_2} \\
    \frac{\partial y}{\partial \theta_1} & \frac{\partial y}{\partial \theta_2}
\end{pmatrix}
```

```python
import numpy as np

def calculate_jacobian_2r_planar(l1, l2, theta1_deg, theta2_deg):
    theta1_rad = np.deg2rad(theta1_deg)
    theta2_rad = np.deg2rad(theta2_deg)

    # Partial derivatives for x
    dx_dtheta1 = -l1 * np.sin(theta1_rad) - l2 * np.sin(theta1_rad + theta2_rad)
    dx_dtheta2 = -l2 * np.sin(theta1_rad + theta2_rad)

    # Partial derivatives for y
    dy_dtheta1 = l1 * np.cos(theta1_rad) + l2 * np.cos(theta1_rad + theta2_rad)
    dy_dtheta2 = l2 * np.cos(theta1_rad + theta2_rad)

    jacobian = np.array([
        [dx_dtheta1, dx_dtheta2],
        [dy_dtheta1, dy_dtheta2]
    ])
    return jacobian

# Link lengths
l1 = 1.0
l2 = 0.8

# Joint angles
theta1 = 30 # degrees
theta2 = 60 # degrees

jacobian_matrix = calculate_jacobian_2r_planar(l1, l2, theta1, theta2)
print("Jacobian Matrix:")
print(jacobian_matrix)

# Conceptual ROS example: using the KDL (Kinematics and Dynamics Library) in ROS
# KDL provides tools to compute Jacobians for URDF models.
# For example, in C++ you might use:
# KDL::ChainFkSolverVel_recursive fk_solver_vel(chain);
# J.data = jacobian_matrix;
```

### ASCII Diagram: Jacobian Mapping

```
Joint Space (q)
  (velocities: dq/dt)
       |
       V
   [Jacobian]
       |
       V
End-Effector Space (x)
  (velocities: dx/dt)
```

### Multiple Choice Question

What does a robot's singularity imply about its motion at that configuration?

a) The robot can move its end-effector in all directions with infinite speed.

b) The robot gains extra degrees of freedom at its end-effector.

c) The robot loses one or more degrees of freedom for its end-effector.

d) The robot's joints are locked and cannot move.

**Answer:** c)

### Short Question

Why is the Jacobian matrix crucial for inverse kinematics problems, especially when dealing with redundant manipulators?

### Assignment

Consider a 3R planar arm with link lengths $l_1, l_2, l_3$. Derive the analytical expression for its $2 \times 3$ Jacobian matrix (relating joint velocities to end-effector linear velocities). Implement a Python function to calculate this Jacobian for given joint angles and link lengths. Provide an example where you use this Jacobian to compute the end-effector velocity for a given set of joint velocities.
