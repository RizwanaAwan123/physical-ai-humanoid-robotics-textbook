---
id: chapter3-sections-3-1-rigid-body-transformations
title: "Rigid Body Transformations: Homogeneous Matrices"
---

## 3.1 Rigid Body Transformations: Homogeneous Matrices

In robotics, precisely describing the position and orientation of a robot's links and joints in 3D space is fundamental. This is achieved through rigid body transformations, which involve both rotation and translation. Homogeneous Transformation Matrices (HTMs) provide a powerful and unified way to represent these transformations, allowing sequences of rotations and translations to be combined through matrix multiplication.

### Coordinate Frames and Transformations

A rigid body's pose (position and orientation) is described relative to a coordinate frame. When a robot moves, its various links and end-effectors have their own local frames, and their poses are transformed relative to a global or base frame.

### Homogeneous Transformation Matrix (HTM)

An HTM combines a $3 \times 3$ rotation matrix $R$ and a $3 \times 1$ translation vector $\mathbf{p}$ into a single $4 \times 4$ matrix:

```latex
T = \begin{pmatrix}
    R_{3 \times 3} & \mathbf{p}_{3 \times 1} \\
    \mathbf{0}_{1 \times 3} & 1
\end{pmatrix}
```
Where $\mathbf{0}_{1 \times 3}$ is a $1 \times 3$ row vector of zeros. This allows a point $\mathbf{x} = (x, y, z)^T$ to be represented as a homogeneous vector $\mathbf{x}_h = (x, y, z, 1)^T$ and transformed as:

```latex
\mathbf{x}'_h = T \mathbf{x}_h
```

### Composition of Transformations

Multiple transformations can be concatenated by multiplying their respective HTMs. For instance, if frame 2 is transformed relative to frame 1 ($T_1^2$), and frame 3 is transformed relative to frame 2 ($T_2^3$), then the transformation from frame 3 to frame 1 ($T_1^3$) is:

```latex
T_1^3 = T_1^2 T_2^3
```

### Example: 3D Homogeneous Transformation in Python (using `scipy.spatial.transform`)

While `numpy` can handle matrix operations, libraries like `scipy` provide more robust tools for rotations.

```python
import numpy as np
from scipy.spatial.transform import Rotation as R_scipy

def create_htm(rotation_matrix, translation_vector):
    htm = np.eye(4)
    htm[:3, :3] = rotation_matrix
    htm[:3, 3] = translation_vector
    return htm

# Define a rotation (e.g., 90 degrees around Z-axis)
rotation_z_90 = R_scipy.from_euler('z', 90, degrees=True).as_matrix()

# Define a translation
translation = np.array([1.0, 2.0, 3.0])

# Create the HTM
htm_frame_to_base = create_htm(rotation_z_90, translation)
print("Homogeneous Transformation Matrix:")
print(htm_frame_to_base)

# Transform a point from the frame to the base
point_in_frame = np.array([0.5, 0.0, 0.0, 1.0]) # Homogeneous coordinate
point_in_base = htm_frame_to_base @ point_in_frame
print(f"\nPoint in frame: {point_in_frame[:3]}")
print(f"Point in base: {point_in_base[:3]}")
```

### ASCII Diagram: Chained Transformations

```
Base Frame (0)
    |
    | T_0^1
    V
Frame 1 (1)
    |
    | T_1^2
    V
Frame 2 (2)
    |
    | T_2^3
    V
End-Effector (3)
```

### Multiple Choice Question

What is the primary advantage of using Homogeneous Transformation Matrices for rigid body transformations in robotics?

a) They simplify the calculation of inverse kinematics.

b) They allow for the combination of rotation and translation into a single matrix operation.

c) They reduce the computational cost of matrix multiplications.

d) They provide a direct representation of joint angles.

**Answer:** b)

### Short Question

Given two homogeneous transformation matrices $T_A^B$ (transform from frame B to A) and $T_B^C$ (transform from frame C to B), how would you find the transformation matrix $T_A^C$ (transform from frame C to A)? Write the formula.

### Assignment

Write a Python program that defines three coordinate frames: a base frame (0), a shoulder frame (1) located at (0,0,0.5) relative to the base and rotated 45 degrees about the Y-axis, and an elbow frame (2) located at (0, 0.3, 0) relative to the shoulder frame. Calculate the homogeneous transformation matrix from the elbow frame to the base frame ($T_0^2$). Print the resulting matrix and use it to transform a point $(0.1, 0.2, 0)$ from the elbow frame to the base frame.
